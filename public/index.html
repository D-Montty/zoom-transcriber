<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Sales Call Transcriber</title>
  <link rel="stylesheet" href="style.css"/>
  <style>
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:linear-gradient(135deg,#667eea,#764ba2);min-height:100vh;margin:0;padding:24px}
    .container{max-width:900px;margin:0 auto}
    header{color:#fff;text-align:center;margin-bottom:20px}
    .card{background:#fff;border-radius:12px;padding:22px;box-shadow:0 12px 28px rgba(0,0,0,.12);margin-bottom:16px}
    label{display:block;font-weight:600;margin-bottom:6px}
    input{width:100%;padding:12px;border:2px solid #e6e6e6;border-radius:8px;font-size:16px}
    .buttons{display:flex;gap:10px;margin-top:14px;flex-wrap:wrap}
    button{border:0;padding:12px 20px;border-radius:8px;font-weight:700;cursor:pointer;transition:opacity 0.2s}
    button:disabled{opacity:0.5;cursor:not-allowed}
    #startBtn{background:#667eea;color:#fff}
    #stopBtn{background:#f56565;color:#fff}
    #copyBtn{background:#48bb78;color:#fff}
    #newSessionBtn{background:#9f7aea;color:#fff;display:none}
    .status{margin-top:12px;padding:10px;border-radius:8px;background:#bee3f8;color:#2c5282}
    .status.error{background:#fed7d7;color:#742a2a}
    .status.success{background:#c6f6d5;color:#22543d}
    #txCard{max-height:520px;overflow:auto}
    .row{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
    #tx{background:#f7f7f9;border-radius:8px;padding:16px;white-space:pre-wrap;min-height:100px}
    footer{color:#fff;text-align:center;margin-top:12px;opacity:.9}
    .live-indicator{display:inline-block;width:8px;height:8px;background:#48bb78;border-radius:50%;margin-left:8px;animation:pulse 2s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:0.3}}
    .session-ended{opacity:0.9;font-style:italic}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üìù Sales Call Transcriber</h1>
      <p>Paste a Zoom link, start, stop, and copy the transcript.</p>
    </header>

    <div class="card">
      <label>Your Name</label>
      <input id="name" placeholder="e.g., Diego"/>

      <label style="margin-top:12px;">Zoom Meeting Link</label>
      <input id="zoom" placeholder="https://zoom.us/j/123..."/>

      <div class="buttons">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
        <button id="copyBtn" disabled>Copy Transcript</button>
        <button id="newSessionBtn">New Session</button>
      </div>

      <div id="status" class="status"></div>
    </div>

    <div class="card" id="txCard" style="display:none;">
      <div class="row">
        <h2 id="txTitle">Live Transcript</h2>
        <span id="duration"></span>
      </div>
      <pre id="tx">Waiting for audio‚Ä¶</pre>
    </div>

    <footer>
      üí° If Zoom shows a participant trying to join, please **Admit** it.
    </footer>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const copyBtn  = document.getElementById('copyBtn');
    const newSessionBtn = document.getElementById('newSessionBtn');
    const statusEl = document.getElementById('status');
    const txEl     = document.getElementById('tx');
    const txCard   = document.getElementById('txCard');
    const txTitle  = document.getElementById('txTitle');
    const durEl    = document.getElementById('duration');

    let botId = null, poll = null, t0 = null, timer = null, sessionEnded = false;

    function setStatus(msg, type="info"){
      console.log(`[STATUS:${type}]`, msg);
      statusEl.textContent = msg;
      statusEl.className = `status ${type}`;
      if(type!=="error") setTimeout(()=>{ if (statusEl.textContent === msg) statusEl.textContent = ""; }, 5000);
    }

    function setButtons({starting=false, running=false, hasFinalTranscript=false}){
      startBtn.disabled = starting || running || hasFinalTranscript;
      stopBtn.disabled  = !running;
      copyBtn.disabled  = !hasFinalTranscript && !running;
      
      // Show "New Session" button only when session has ended and we have a transcript
      if(hasFinalTranscript){
        newSessionBtn.style.display = 'inline-block';
      }
    }

    async function start(){
      try{
        const name = document.getElementById('name').value.trim();
        const zoom = document.getElementById('zoom').value.trim();
        if(!zoom){ setStatus("Please paste a Zoom meeting link", "error"); return; }

        setButtons({starting:true, running:false});
        setStatus("Starting bot‚Ä¶ admit it in Zoom if prompted.");
        console.log("POST /api/start", { zoom_url: zoom, display_name: name });

        const r = await fetch("/api/start", {
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body: JSON.stringify({ zoom_url: zoom, display_name: name })
        });

        const rawText = await r.text();
        let data = {};
        try { data = JSON.parse(rawText); } catch { data = { raw: rawText }; }
        console.log("START response:", r.status, data);

        if(!r.ok){
          const msg = data?.error || data?.details || data?.message || rawText || "Failed to start";
          setStatus(`Start error (${r.status}): ${msg}`, "error");
          setButtons({starting:false, running:false});
          return;
        }

        botId = data.bot_id;
        sessionEnded = false;
        txCard.style.display = "block";
        txEl.textContent = "Waiting for audio‚Ä¶";
        txEl.classList.remove('session-ended');
        txTitle.innerHTML = 'Live Transcript <span class="live-indicator"></span>';
        setButtons({running:true});
        setStatus("Recording started! Bot joined the meeting.", "success");
        
        t0 = Date.now();
        timer = setInterval(()=>{
          const s = Math.floor((Date.now()-t0)/1000);
          const m = String(Math.floor(s/60)).padStart(2,"0");
          const ss = String(s%60).padStart(2,"0");
          durEl.textContent = `Duration ${m}:${ss}`;
        }, 1000);

        // Poll every 3s ‚Äî try live cache first, then REST fallback
        poll = setInterval(async ()=>{
          if (!botId || sessionEnded) return;

          try {
            // 1) Live via webhook cache
            const live = await fetch(`/api/live?bot_id=${botId}`);
            if (live.ok) {
              const ld = await live.json();
              if (ld.hasData && typeof ld.transcript === "string" && ld.transcript.trim()) {
                txEl.textContent = ld.transcript;
                txEl.scrollTop = txEl.scrollHeight;
                return; // got live text; skip REST this tick
              }
            }

            // 2) Fallback to REST transcript (may be empty until post-call)
            const rest = await fetch(`/api/transcript?bot_id=${botId}`);
            if (rest.ok) {
              const rd = await rest.json();
              if (rd.transcript && rd.transcript.trim()) {
                txEl.textContent = rd.transcript;
                txEl.scrollTop = txEl.scrollHeight;
              } else {
                console.debug("Transcript not ready yet (REST). State:", rd?.state);
              }
            } else {
              console.warn("REST transcript error", rest.status);
            }
          } catch (e) {
            console.error("Polling error:", e);
          }
        }, 3000);

      }catch(e){
        console.error("Start() crashed:", e);
        setStatus(`Unexpected error: ${e.message}`, "error");
        setButtons({starting:false, running:false});
      }
    }

    async function stop(){
      if(!botId) return;
      setStatus("Stopping recording...");
      
      try{
        const r = await fetch("/api/stop", {
          method:"POST",
          headers:{"Content-Type":"application/json"},
          body: JSON.stringify({ bot_id: botId })
        });
        const data = await r.json().catch(()=> ({}));
        console.log("STOP response:", r.status, data);

        // Stop polling and timers immediately
        sessionEnded = true;
        if(poll){ clearInterval(poll); poll = null; }
        if(timer){ clearInterval(timer); timer = null; }
        
        // Update UI to show session ended
        txTitle.textContent = 'Final Transcript';
        txEl.classList.add('session-ended');

        if(!r.ok){
          setStatus(`Stop error (${r.status}): ${data?.error || data?.details || "Failed to stop"}`, "error");
          setButtons({starting:false, running:false, hasFinalTranscript: false});
          return;
        }
        
        // Check if we got a transcript immediately
        if (typeof data.transcript === "string" && data.transcript.trim()){
          txEl.textContent = data.transcript;
          setButtons({starting:false, running:false, hasFinalTranscript: true});
          setStatus("‚úÖ Recording stopped! Transcript ready to copy.", "success");
        } else {
          // Keep polling until the final transcript appears
          setStatus("Processing final transcript...");
          setButtons({starting:false, running:false, hasFinalTranscript: false});
          
          const pollUntilReady = async () => {
            try {
              const rr = await fetch(`/api/transcript?bot_id=${botId}`);
              const td = await rr.json().catch(()=> ({}));
              if (td.transcript && td.transcript.trim()) {
                txEl.textContent = td.transcript;
                setButtons({starting:false, running:false, hasFinalTranscript: true});
                setStatus("‚úÖ Recording stopped! Transcript ready to copy.", "success");
              } else {
                // Keep trying every 5 seconds
                setTimeout(pollUntilReady, 5000);
              }
            } catch(e) {
              console.error("Polling final transcript error:", e);
              setTimeout(pollUntilReady, 5000);
            }
          };
          pollUntilReady();
        }
      }catch(e){
        console.error("Stop() crashed:", e);
        setStatus(`Unexpected error: ${e.message}`, "error");
        sessionEnded = true;
        if(poll){ clearInterval(poll); poll = null; }
        if(timer){ clearInterval(timer); timer = null; }
        setButtons({starting:false, running:false, hasFinalTranscript: false});
      }
    }

    function copy(){
      const text = txEl.textContent || "";
      if(!text.trim() || text === "Waiting for audio‚Ä¶"){ 
        setStatus("Nothing to copy yet", "error"); 
        return; 
      }
      navigator.clipboard.writeText(text).then(
        ()=> setStatus("‚úÖ Transcript copied to clipboard!", "success"),
        ()=> setStatus("Copy failed - please select and copy manually", "error")
      );
    }

    function newSession(){
      // Reset everything for a new session
      botId = null;
      sessionEnded = false;
      txCard.style.display = 'none';
      txEl.textContent = 'Waiting for audio‚Ä¶';
      txEl.classList.remove('session-ended');
      durEl.textContent = '';
      txTitle.textContent = 'Live Transcript';
      newSessionBtn.style.display = 'none';
      setButtons({starting:false, running:false, hasFinalTranscript: false});
      setStatus("");
    }

    startBtn.onclick = start;
    stopBtn.onclick  = stop;
    copyBtn.onclick  = copy;
    newSessionBtn.onclick = newSession;

    // Keyboard shortcuts
    document.addEventListener("keydown", (e) => {
      if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="s"){ 
        e.preventDefault(); 
        if(!startBtn.disabled) start(); 
      }
      if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="x"){ 
        e.preventDefault(); 
        if(!stopBtn.disabled) stop(); 
      }
      if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="c" && copyBtn.offsetParent !== null){ 
        // Only trigger if copy button is visible
        if(!copyBtn.disabled){
          e.preventDefault();
          copy();
        }
      }
    });
  </script>
</body>
</html>
